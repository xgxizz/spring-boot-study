https://blog.csdn.net/qq_34197740/article/details/107474185
注意以下所提到的当前事务即内层的事务。

UserServiceOuter-外层服务
UserServiceInner-内层服务

一、事务传播机制

1.PROPAGATION_REQUIRED（默认）
Spring默认的传播机制，能满足绝大部分的业务需求。
1）如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚（即在内外层方法都有@Transactinal注解，内外两层任何一方发生异常，都会发生回滚）。
2）如果外层没有事务，(内层自己)新建一个事务执行，外层发生异常不影响内层事务执行。

2.PROPAGATION_REQUES_NEW
  该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可.
1）内层方法抛出异常，外层方法正常执行 ---内层外层事务均回滚
2）外层方法抛出异常，内层方法正常执行 ---内存事务正常执行，外层事务不回滚
3）外层方法删掉事务注解，内层方法抛出异常  ---外层正常执行不回滚，内层事务回滚
结论
内层事务方法的回滚会影响到外层事务方法一起回滚
外层事务的回滚不会影响到内层事务，内层事务回滚 / 提交完全看自己，而外层事务的回滚提交不仅要看自己也看内层事务

3.PROPAGATION_SUPPORT
如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务.
1）内层方法抛出异常，外层方法正常执行 ---内层外层事务均会回滚
2）外层方法抛出异常，内层方法正常执行 ---内层外层事务均会回滚
3）外层方法删掉事务注解，内层方法抛出异常 ---完全依赖于外层，外层没有事务，直接合并当作一个非事务方法执行

4.PROPAGATION_NOT_SUPPORT
1）内层方法抛出异常，外层方法正常执行 --- 内层不支持事务，无论怎样都不会回滚。外层背锅回滚。
2）外层方法抛出异常，内层方法正常执行 --- 外层回滚，内存无论怎样都不会回滚。
3）外层方法删掉事务注解，内层方法抛出异常 --- 外层没有事务不会回滚，内存无论怎样都不会回滚。

5.PROPAGATION_NEVER
1）外层内层都加事务，都正常执行 ---运行时异常，内层外层都会回滚
2）外层不加事务，内层抛出个异常 ---内层抛出个异常，很神奇的是内层和外层都没有回滚（就很神奇）

6.PROPAGATION_MANDATORY
这种传播机制的意思是如果外层没有事务，则抛出异常
1）外层不加事务,执行到调用内层方法时直接抛异常，因为外层没有加事务注解，所以不会回滚
2）外层加上事务注解后结合默认的PROPAGATION_REQUIRED执行效果相同了

7.PROPAGATION_NESTED
该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的
内层事务会跟着外层事务的回滚而回滚，无论内层事务抛出异常回滚与否
外层事务如果没有抛出异常，外层事务必定会提交。
内层事务抛出异常，外层事务会回到savepoint保存点，内层事务单独回滚，就像没有执行过一样。
核心还是这个保存点
需要try包裹住内层事务

二、事务不生效的原因
**原因一：**是否是数据库引擎设置不对造成的。比如我们最常用的mysql，引擎MyISAM，是不支持事务操作的。需要改成InnoDB才能支持

**原因二：**入口的方法必须是public，否则事务不起作用（这一点由Spring的AOP特性决定的，理论上而言，不public也能切入，但spring可能是觉得private自己用的方法，应该自己控制，不应该用事务切进去吧）。另外private 方法, final 方法 和 static 方法不能添加事务，加了也不生效

**原因三：Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚（至于为什么spring要这么设计：因为spring认为Checked的异常属于业务的，coder需要给出解决方案而不应该直接扔该框架）

原因四：@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 <tx:annotation-driven />
备注：本系列所有博文的讨论都针对于springboot而不再对spring做说明。
@EnableTransactionManagement 在springboot1.4以后可以不写。框架在初始化的时候已经默认给我们注入了两个事务管理器的Bean（JDBC的DataSourceTransactionManager和JPA的JpaTransactionManager ），其实这就包含了我们最常用的Mybatis和Hibeanate了。当然如果不是AutoConfig的而是自己自定义的，请使用该注解开启事务

**原因五：**请确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效）

**原因六：**请确保你的业务和事务入口在同一个线程里，否则事务也是不生效的

**原因六：**也是我最想要去讲的一个原因：service方法中调用本类中的另一个方法，事务没有生效。
如果在加有事务的方法内，使用了try...catch..语句块对异常进行了捕获，而catch语句块没有throw  new RuntimeExecption异常，事务也不会回滚

